---
tags: Java, Basic, Lambda, Method References
title: Lambda
---
# Лямбда-выражения

## Примеры
```java=
() -> 123.45
(n) -> (n % 2) == 0
(int n) -> (n % 2) == 0

(n, v) -> {
    int result = 1;
    return result;
}
```

## Использование внешних переменных

В лямбда можно использовать локальную переменную объемлющего метода (захват переменной) если она является действительно завершённой (не обязательно использовать слово final, но она должна присваиваться только один раз). В самом лямбда-выражении её менять тоже нельзя.

# Ссылки на методы

Ссылку можно передавать вместо лямбда-выражений.

**имя_класа::имя_метода** - ссылка на статический метод.
```java=
DoubleFunction<Double> sqrt = Math::sqrt;
System.out.println(sqrt.apply(4));
```

**ссылка_на_объект::имя_метода** - ссылка на методы экземпляра.
```java=
Consumer<String> printer = System.out::println;
printer.accept("Hello");
```

Так же можно получить ссылку на НЕ СТАТИЧЕСКИЙ метод экземпляра, используя класс (**имя_класса::имя_метода_экземпляра**). Тогда в метод надо будет сначала передать экземпляр класса.
```java=
BiConsumer<PrintStream, String> printer = PrintStream::println;
printer.accept(System.out, "Hello");
```

**имя_класса::new** - ссылка на конструктор
```java=
UnaryOperator<String> cons = String::new;
String str = cons.apply("Hello");
System.out.println(str);
```

## Advanced - ссылки на обощённые методы

```java=
interface In {
    Integer fun(Integer object);
}
```

**имя_класса::<тип>статический_метод** - ссылка на методы использующие обобщения
```java=
class Cl {
    static <T> T staticFunction(T var) {
        return var;
    }
}
...
In in = Cl::<Integer>staticFunction;
//In in = Cl::staticFunction; //Так тоже будет работать
```

Аналогично для **ссылка_на_объект::<тип>имя_метода**.
```java=
class Cl {
    <T> T func(T var) {
        return var;
    }
}
...
In in = new Cl()::<Integer>func;
//In in = new Cl()::func; //Так тоже будет работать
```

:::danger
Однако создать так **класс::<тип>не_статический_метод** нельзя.
```java=
class Cl {
    <T> T func(T var) {
        return var;
    }
}
...
In in = Cl::<Integer>func; //НЕЛЬЗЯ
```
:::

Для обобщённых классов возможен только вариант создания **объект::метод** из-за [6 пункта](/tUcKWR8mTXmqC4XP2WXoJA), где всё работает как с обычными методами.

# Функциональный интерфейс

==Функциональный интерфейс== это интерфейс с одним абстрактным методом (метод по умолчанию не считается абстрактным).

Лямбда-выражение реализует абстрактный метод функционального интерфейса и фактически создаёт анонимный класс.

## Предопределённые функциональные интерфейсы

[Встроенные функциональные интерфейсы](https://metanit.com/java/tutorial/9.3.php)

| Интерфейс           | Назначение                                                                                                        |
| ------------------- | ----------------------------------------------------------------------------------------------------------------- |
| `UnaryOperator<T>`  | Выполняет унарную операцию над объектом типа Т и возвращает результат того же типа. Содержит метод `T apply(T)`   |
| `BinaryOperator<T>` | Выполняет операцию над двумя объектами типа Т и возвращает результат того же типа. Содержит метод `T apply(T, T)` |
| `Consumer<T>`       | Выполняет операцию над объектом типа T. Содержит метод `void accept(T)`                                           |
| `Supplier<T>`       | "Поставщик". Возвращает объект типа T. Содержит метод `T get()`                                                   |
| `Function<T, R>`    | Функция преобразования из типа T в R. Содержит метод `R apply(T)`                                                 |
| `Predicate<T>`      | Представляет из себя проверку условия. Как правило используется в if. Содержит метод `boolean test(T)`            |

